Often times, developers of probabilistic programming libraries must construct domain-specific languages to express restrictions which are required by the system. An excellent example is MCMC kernel DSLs (or Gaussian process kernel DSLs) where a set of mathematical restrictions (which cannot be enforced by the compiler) must apply to user code for the code to qualify as a valid kernel. The dominant methodology in languages with macro systems is to construct the DSL using macros. The library can check at macro-expansion time if the user has utilized syntax or language features which are disallowed by the DSL, returning immediately to the user to express an error or issue. In extreme cases, the user may only be allowed to use other macros (which represent primitive features of the DSL) inside the DSL macro.

Because Jaynes aims for composability and integration with the compiler, we prefer a complementary viewpoint which "carves" the DSL out of the host language. We call this approach _contextual domain-specific languages_. Because the inclusion of language features is handled by the interpretation context, these DSLs are naturally composable. The interpretation context contains a "language core" which is a piece of metadata which tells the interpreter what method calls are allowed in the DSL. Composition of language cores is defined as set intersection (i.e. the minimal feature set which is compatible with both languages). In this perspective, interpretation without a core is just interpretation of the entire host language in the context - nothing is excluded.

As an example of this idea, here's a small functional core which prevents the use of mutation.
